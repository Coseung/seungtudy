![](https://velog.velcdn.com/images/dreamdp01/post/6a70d6bd-4991-42ec-b9a5-f44e7029a089/image.png)
## 상속과 조합 개념 정리 
객체지향 프로그래밍을 학습 하면서, 코드의 중복을 줄이고 재사용성을 높이는 두가지 방법인 **상속**과 **조합**에 대해 알게 되었다. 두 개념의 차이점과 각각 언제 사용해야하는지 정리 해보았다. 

### 상속(Inheritance)
상속은 extends 키워드를 사용하여 기존에 정의되어 있는 클래스(부모)의 필드와 메소드를 물려받아 새로운 클래스(자식)를 생성하는 기법이다. 보통 `IS-A` 관계가 성립할때 사용 된다.

#### IS-A 관계 (Is a Relationship)

- 말 그대로 **"~은 ~이다"**가 성립하는 관계를 의미한다.

- 하위 클래스는 상위 클래스의 한 종류여야 한다.

예시: Dog is an Animal (개는 동물이다), Apple is a Fruit (사과는 과일이다).

#### 상속의 특징:

- 기존 코드를 재사용하여 중복을 제거할 수 있다.

- 클래스 간의 계층적인 구조를 만들 수 있다.

#### 상속의 문제점 (학습하며 알게 된 점)
처음에는 코드 재사용이 편해서 상속이 무조건 좋은 줄 알았으나, 학습해 보니 다음과 같은 문제점이 존재했다.

- **결합도가 높고 캡슐화를 해친다**. 하위 클래스가 상위 클래스의 구현에 강하게 의존하게 된다. 만약 상위 클래스의 내부 구현이 변경되면, 이를 상속받은 하위 클래스의 코드도 영향을 받아 수정해야 할 수도 있다.

- **불필요한 기능이 노출된다**. 상속을 받으면 상위 클래스의 모든 public 메소드가 하위 클래스에도 그대로 노출된다. 하위 클래스에서 사용하면 안 되는 기능까지 사용자에게 노출될 수 있다.

---
## 조합 (Composition)
조합은 기존 클래스를 상속받는 것이 아니라, 새로운 클래스 내부에서 기존 클래스의 객체를 필드(변수)로 포함하는 방식이다. 보통 `HAS-A `관계가 성립할 때 사용한다.

#### HAS-A 관계 (Has a Relationship)

- **"~은 ~을 가지고 있다(포함한다)"**가 성립하는 관계를 의미한다.

- 하나의 객체가 다른 객체의 부품이 되거나, 구성 요소가 되는 경우다.

예시: Car has an Engine (자동차는 엔진을 가지고 있다), Police has a Gun (경찰은 총을 가지고 있다).


#### 조합의 특징:

- 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함하여 기능을 재사용한다.

- 상속과 달리 부분 객체의 내부 구현이 공개되지 않는다.

- 메소드를 호출하는 방식으로 사용하므로, 부분 객체의 내부가 변경되어도 퍼블릭 인터페이스만 그대로라면 영향을 받지 않는다. (낮은 결합도)

---

## 코드 비교: 상속 vs 조합 (캡슐화 문제)
상속이 어떻게 캡슐화를 해치는지 보여주는 유명한 예제(Effective Java)인 HashSet의 요소 추가 횟수 카운팅 예시로 비교해 보았다.

#### 상속을 사용한 경우
HashSet을 상속받아 add와 addAll을 오버라이딩하여 카운트를 증가시키도록 구현했다.

```java
public class CountSet extends HashSet<String> {
    private int addCount = 0; // 추가 횟수 저장

    @Override
    public boolean add(String e) {
        addCount++; // 카운트 1 증가
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends String> c) {
        addCount += c.size(); // 리스트 크기만큼 카운트 증가
        return super.addAll(c);
    }
    
    public int getAddCount() {
        return addCount;
    }
}
```
문제: 이 코드로 아래와 같이 실행하면 addCount는 3이 나와야 할 것 같지만, 실제로는 6이 나온다.
```
6
```


```java
CountSet set = new CountSet();
set.addAll(List.of("A", "B", "C")); // 3개 추가
System.out.println(set.getAddCount()); // 6 (네???)
```

이유: 부모 클래스인 HashSet의 addAll 메소드가 내부적으로 자기 자신의 add를 호출하기 때문이다.(캡슐화 해침)

- 내가 `addAll`을 호출해서 카운트가 `+3` 된다.

- `super.addAll`이 실행되면서 내부에서 루프를 돌며 `add`를 호출한다.

- 이때 오버라이딩된 나의 `add`가 실행되면서 카운트가 또 `+3` 된다.

결과적으로 두 번 카운팅되어버린다.

결국 부모 클래스의 내부 구현 방식(addAll이 add를 부른다는 사실)을 모르면 코드가 오작동한다. 이는 자식 클래스가 부모 클래스의 내부 구현에 강하게 의존하게 되어 캡슐화가 깨진 것이다.

---
#### 조합을 사용한 경우
상속받는 대신, HashSet을 내 클래스의 **필드(부품)**로 가지고 있으면 이 문제가 해결된다.


```java
public class CountSet {
    // 1. 상속받지 않고, 사용할 객체를 필드로 가짐 (HAS-A)
    private final Set<String> set = new HashSet<>();
    private int addCount = 0;

    // 2. 기능을 위임 (Delegate)
    public void add(String e) {
        addCount++;
        set.add(e);
    }

    public void addAll(Collection<String> c) {
        addCount += c.size();
        set.addAll(c); // 내부의 set에게 일을 시킴
    }

    public int getAddCount() {
        return addCount;
    }
}
```
해결:

이제 `addAll`을 호출하면 내 클래스의 `addCount`를 증가시키고, 내부 필드인 `set.addAll()`을 호출한다.

`set.addAll()`이 내부적으로 add를 호출하든 말든, 그것은 set 내부의 일이지 내 클래스의 add 메소드와는 상관이 없다.

결과적으로 카운트는 정확히 3이 나온다. 부모의 내부 구현을 몰라도 내 코드는 안전하게 동작한다

---
## 결론 (내가 이해한 바)
학습한 내용을 바탕으로 정리하자면, 무조건적인 상속보다는 조합을 우선적으로 고려하는 것이 좋은 설계인 것 같다.

상속은 부모와 자식 간의 관계가 명확한 IS-A 관계이고, 부모의 내부 구현에 의존해도 괜찮을 만큼 관계가 밀접할 때만 신중하게 사용해야 한다.

단순히 코드 중복을 줄이거나 기능을 재사용하고 싶은 목적이라면, **조합**을 사용하여 내부 구현을 숨기고 필요한 기능만 노출하는 것이 유지보수와 유연성 측면에서 훨씬 유리한것 같다.