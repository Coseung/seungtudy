람다식에 대해 공부한 내용을 정리한 글입니다. 

## 람다식(Lambda)이란 
람다식은 **메서드를 하나의 식으로 표현한 것**입니다. 메서드의 이름과 반환 타입을 제거하고 `->` 화살표를 사용 해서 코드를 더 간결하게 만듭니다. 

---
## 람다 도입 
람다는 자바 8에 도입이 되었습니다. 자바 8 이전에는 메서드 하나를 전달 하기 위해 객체를 생성해야 했지만 람다 도입 후에는 **동작 자체를 변수처럼 전달을 할 수 있게 되었습니다**.
![](https://velog.velcdn.com/images/dreamdp01/post/b1982118-b32b-4c33-8e89-c3f7ee813423/image.png)

---
## 기존 방식
예를들어 문자열 리스트를 알파벳 순으로 정렬하려면 Comparator 인터페이스를 구현해야합니다. 이를 익명 내부 클래스를 사용하여 구현 합니다.
```java
List<String> words = Arrays.asList("Java", "Lambda", "Code");

Collections.sort(words, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.compareTo(s2); // <--- 필요한 로직 한 줄
    }
});
```
정작 중요한 로직은 한줄뿐이고 나머지는 오로지 형식을 맞추는 코드입니다. `new Comparator` `pulic int compare` 등 문법적인 요소가 너무 많지 않나요? 

---
## 람다 방식
```java
Collections.sort(words, (s1, s2) -> s1.compareTo(s2));
```
람다를 사용하면 다 걷어내고 필요한 로직만 남길 수 있게 됩니다.


### 람다 작성 규칙 
람다식은 `(매개변수) -> {실행문}` 형식을 따르고 컴파일러의 타입 추론 덕분에 많은 부분을 생략 할 수 있습니다. 

#### 기본
```java
(int a, int b) -> {return a+b; }
```
#### 매개변수 타입 생략
```java
(a, b) -> {return a+b; }
```

#### 소괄호 () 생략 
매개변수가 하나일때 가능
```java
a->a*a
```
#### 중괄호 {}, return 생략
실행문이 한줄이고 리턴값이 있는경우 가능
```java
(a,b) -> a+b
```

---
## 람다 동작원리
람다식이 가능한 이유는 해당 인터페이스가 *하나의 추상메서드* 만 가지고 있기 때문입니다. 이를 함수형 인터페이스로 불립니다.

```
public interface MyCalculator {
    int calculate(int a, int b);
}

//사용예시
MyCalculator adder = (a, b) -> a + b;
```

### 그럼 사용 할때마다 함수형 인터페이스를 정의 해야하냐 

> NONO

java.util.function 패키지 라는 자바에서 제송하는 표준 인터페이스를 활용할 수 있습니다.

| 인터페이스 | 메서드 | 특징 |
| :--- | :--- | :--- |
| `Predicate<T>` | `boolean test(T t)` | 조건식 판단 (참/거짓 반환) |
| `Consumer<T>` | `void accept(T t)` | 값을 받아서 소비 (리턴값 없음) |
| `Supplier<T>` | `T get()` | 값을 공급 (매개변수 없음, 리턴값 있음) |
| `Function<T, R>` | `R apply(T t)` | 값을 받아 다른 타입으로 변환 후 반환 |

---
## 메서드 참조 
람다식이 단순한 하나의 메서드만 호출하는 경우에는 더 간략화 하여 **메서드 참조**를 사용할 수 있습니다. 

문법: `클래스명::메서드명` 또는 `참조변수::메서드명`

```java
(s) -> System.out.println(s) ⇒ System.out::println

(x, y) -> Math.max(x, y) ⇒ Math::max
```
매개변수 `s` 도 치기 싫을때, 변수 이름 뭘로 지을지 고민할때 사용하면 좋을것같습니다

> 참고로 개발자 3대 덕목중 하나가 나태함 입니다 ..
![](https://velog.velcdn.com/images/dreamdp01/post/2054e949-d0a2-4330-affc-ac030aa39637/image.png)


---
## 람다 쓰면 안좋은 경우 

### this 사용 시
익명 내부 클래스에서의 `this`는 익명 클래스 인스턴스 자신을 가리키지만 람다식은 람다식을 감싸고 잇는 외부 클래스의 인스턴스를 가리킵니다.
즉, 람다 내부에서는 자기 자신을 참조할 수 없습니다.

### 변수 쉐도잉 불가 
**쉐도잉이란** 외부 스코프에 있는 변수와 똑같은 이름의 변수를 내부에서 선언하여, 외부 변수가 가려지는 현상을 말합니다.

**익명 내부 클래스**: 새로운 스코프가 생성되므로, 외부 변수와 같은 이름의 변수를 선언하면 쉐도잉이 발생합니다.

**람다식**: 람다의 바디는 외부와 같은 스코프를 공유합니다. 따라서 외부 변수와 이름이 같은 변수를 선언하려고 하면 컴파일 에러가 발생합니다.
![](https://velog.velcdn.com/images/dreamdp01/post/83509779-abda-463b-88f6-3af934131758/image.png)




### 가독성 문제 
람다는 이름이 없는 **익명 함수**입니다. 코드가 길어지면 이 코드가 도대체 무슨 역할을 하는지 구현된 내용을 봐야 유추를할 수 있습니다.

![](https://velog.velcdn.com/images/dreamdp01/post/83f56feb-1db9-4d55-9047-2f7d7fd6f670/image.png)

오직 코드의 동작만 보고 알아내야 하기 때문에 코드가 길어 진다면 차라리 **익명 클래스**를 작성하여 어떤 기능을 하는지 메서드 이름으로 파악할 수 있겠죠?
![](https://velog.velcdn.com/images/dreamdp01/post/aff9cb03-258d-484b-9a67-20ec00bffe93/image.png)


---
## 결론

이번에 람다를 정리하면서 느낀점은, 람다가 단순히 코드를 줄여주는 도구가 아니라. 오히려 객체지향 언어인 자바에서 함수형 프로그래밍의 장점을 빌려올수 있는 도구 라는 생각이 들었습니다. 

