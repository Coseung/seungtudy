스프링 프레임의크를 알아 보다보면 제어의 역전(IoC), 의존성 주입(DI)라는 개념이 나온다. 그 개념을 간단하게 짚어 넘어갈 것이다. 

## 제어의 역전(IoC)

`IoC`는 제어의 역전(Inversion of Control)의 줄임말이다.
원래 일반적인 프로그램은 객체의 생명주기를 개발자가 직접 관리한다. 라이브러리를 호출할 때에도 호출 시점을 개발자가 관리하게 된다.

예를 들어
```java
Person per = new Person();
```

이 코드처럼 직접 객체를 생성하면, `Person` 클래스에 직접 의존하게 된다. 
`왜 의존적인가?`
→ 객체를 직접 생성했기 때문에, 나중에 `Person`을 다른 구현체로 바꾸거나 테스트용 객체로 대체하려면 이 코드를 수정해야 한다. 즉, 사용하는 쪽 코드가 생성 방식과 구현체에 묶여 결합도가 높아진다.

하지만 제어의 역전은 다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와서 사용한다.
스프링 프레임워크를 사용할 때는 대표적으로 `Controller`와 `Service` 같은 객체의 생성 시점이나 소멸 시점을 따로 구현하지 않아도 된다. 스프링 컨테이너가 객체를 생성하고 필요에 따라 관리한다.

제어의 역전의 예시
```java
public class A {
    private MemberService memberService;
    // 어딘가에서 객체를 받아옴
}
```

이 코드를 보면 new로 객체를 직접 생성하지 않고 어딘가에서 받아와서 사용하고 있다. 이 “어딘가”는 스프링 컨테이너이다.
스프링 컨테이너는 객체를 생성하고 관리하는 컨테이너이다. 즉 객체 생성과 관리의 제어권이 개발자가 아니라 스프링 컨테이너로 넘어갔고, 그걸 “역전”이라고 표현한다.


---
## 의존성 주입(DI)

의존성 주입(DI)은 필요한 객체(의존성)를 외부에서 생성해서 클래스에 주입해주는 방식이다. 즉, 클래스 내부에서 new로 직접 만들지 않고 스프링 컨테이너가 만들어서 넣어준다.

의존성 주입은 제어의 역전을 구현하기 위해 사용하는 방법 중 하나이다. 하지만 `IoC === DI` 는 틀린 말이다.
IoC는 “제어권이 외부로 넘어간다”는 큰 개념이고, DI는 그걸 구현하는 대표적인 방법이다.

#### IoC인데 DI는 아닌 예시

아래 컨트롤러 코드는 의존성 주입(DI)을 사용하지 않는다.
```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

그런데도 IoC(제어의 역전)는 성립한다. 이유는 `hello()`메서드를 개발자가 직접 호출하는 게 아니라, 사용자가 `/hello`로 요청을 보내면 스프링 **MVC(DispatcherServlet)**가 요청을 처리하면서 매핑 정보를 보고 hello()를 자동으로 호출하기 때문이다.
즉, 언제 어떤 메서드를 실행할지에 대한 제어권이 개발자가 아니라 프레임워크에 있으므로 `IoC`이고, 이처럼 `IoC`는 `DI`가 없어도 발생할 수 있어 `IoC === DI`는 틀린 말이다.


의존성 주입을 왜 하는가? 에 대한 글은 다른 글에 정리해 놓았으니 링크를 클릭하고 보면 좋을 것 같다.

https://velog.io/@dreamdp01/%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%84-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0
![](https://velog.velcdn.com/images/dreamdp01/post/d06073b4-e927-4f84-bd18-2cdb6962d21c/image.png)
