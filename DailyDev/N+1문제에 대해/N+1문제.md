

## N+1문제란?
N+1 문제는 JPA와 같은 ORM을 사용하여 데이터를 조회하는 과정에서 관련데이터를 조회 할때 발생하는 문제입니다. 
한개의 쿼리를 날렸는데 N개의 쿼리가 추가로 날라가는 문제입니다. 

---
## 언제 문제가 터져요? 
만약 투두 리스트 를 간단하게 만들었다고 치면
![](https://velog.velcdn.com/images/dreamdp01/post/3a9f6ca9-f8c2-4fcb-9c8f-902ea8af304c/image.png)
멤버랑 오늘 할일 테이블이 있을 것입니다. 
![](https://velog.velcdn.com/images/dreamdp01/post/6df7e62a-7eb7-4262-b643-881c1d303864/image.png)

여기서 한 멤버의 엔티티에는 할일 리스트를 담아 놓은 컬럼이 있겠죠? 

만약 DB에는 현재 5명의 멤버가 저장되어 있고, 각 멤버는 할 일을 가지고 있다고 가정해 봅시다. 우리는 **"모든 멤버의 이름과 그 멤버가 가진 할 일들의 내용"**을 출력하고 싶다면

```java
// 1. 모든 멤버를 조회
    List<Member> members = memberRepository.findAll();

    // 2. 멤버 수만큼 반복문을 돌면서 할 일을 출력
    for (Member member : members) {
        System.out.println("멤버: " + member.getName());
       
        for (Todo todo : member.getTodoList()) {
            System.out.println(" - 할 일: " + todo.getContent());
        }
    }
```
이런식의 코드를 작성해야합니다 
먼저 모든 멤버를 가져오는 쿼리가 **한번** 날라갈 것이고 
그다음 멤버의 수만큼 반복문을 돌면서 할일 을 출력하는 for문을 실행하는 순간 
```java
-- 1. 먼저 멤버 전체를 조회하는 쿼리 (1번)
Hibernate: select * from member

-- 2. 첫 번째 멤버의 Todo를 가져오기 위한 쿼리 (N번째 - 1)
Hibernate: select * from todo where member_id = 1

-- 3. 두 번째 멤버의 Todo를 가져오기 위한 쿼리 (N번째 - 2)
Hibernate: select * from todo where member_id = 2

-- 4. 세 번째 멤버의 Todo를 가져오기 위한 쿼리 (N번째 - 3)
Hibernate: select * from todo where member_id = 3

... (멤버 수만큼 계속 반복) ...
```
이렇게 쿼리가 무수히 반복 되는 문제가 발생합니다. 이게 N+1문제 이구요




---
## 왜 이렇게 많이 나가요? 
무수히 쿼리가 많이 나가는 이유는 다음과 같습니다

첫번째로
```java
List<Member> members = memberRepository.findAll();
```
이 코드를 실행시켰을때 멤버의 테이블을 다 가져오겠죠?? 
멤버의 테이블에서 데이터들은 객체로 변환되어 영속성 컨텍스트에 들어가게되고 할일 테이블과 연관되어있는 오늘 할일 List는 가짜 객체로 체워지게 됩니다.
![](https://velog.velcdn.com/images/dreamdp01/post/cf9d2c00-c8fa-4386-a56a-000d53120041/image.png)

두번째로는 모든 멤버의 이름과 그 멤버가 가진 할 일들의 내용 을 가져오도록하는 다음코드를 실행 합니다.
```java
 for (Member member : members) {
        System.out.println("멤버: " + member.getName());
       
        for (Todo todo : member.getTodoList()) {
            System.out.println(" - 할 일: " + todo.getContent());
        }
```
이때 리스트는 가짜객체로 채워져있고 데이터가 없으니 셀렉트 쿼리가 날라가게 됩니다. 
```
Hibernate: select * from todo where member_id = 1
```
그리고 2번의 멤버의 차례가 왔고 코드를 실행 시키면 마찬가지고 가짜객체로 채워져있어 데이터가 없어 쿼리가 날라가게 됩니다.
```
Hibernate: select * from todo where member_id = 2
```
![](https://velog.velcdn.com/images/dreamdp01/post/9cb160e4-9e3a-4b5c-86b8-a25e35fec9f1/image.png)

이렇게 하나의 쿼리만사용해서 가져올수 있던 데이터를 N개의 추가 쿼리를 발생시키는 코드가 탄생하게 됩니다

---

## 해결방법 
N+1 문제를 해결하는 가장 일반적인 방법은 JPQL의 **패치 조인(Fetch Join)**을 사용하는 것입니다.

패치 조인은 JPQL에서 성능 최적화를 위해 제공하는 기능으로, 연관된 엔티티나 컬렉션을 SQL의 조인을 이용하여 한 번에 조회하는 방식입니다.

```java

public interface MemberRepository extends JpaRepository<Member, Long> {

    // Member를 조회할 때 연관된 TodoList를 함께 조회하도록 명시
    @Query("select m from Member m join fetch m.todoList")
    List<Member> findAllJoinFetch();
}
```
#### 패치 조인의 동작 원리

1. SQL Join 생성: JPQL의 join fetch 구문은 SQL의 INNER JOIN으로 변환되어 실행됩니다

2. 단일 쿼리 조회: 쿼리 실행 시 MEMBER와 TODO 테이블을 조인하여, 필요한 모든 데이터를 하나의 쿼리(SELECT M.*, T.* ...)로 가져옵니다

3. DB에서 조회한 데이터를 기반으로 Member 엔티티와 그 내부의 Todo 컬렉션을 모두 실제 엔티티로 생성하여 영속성 컨텍스트에 저장합니다

결과: 엔티티가 이미 실제 데이터로 채워져 있으므로, `getTodoList()`를 호출하더라도 이젠 데이터베이스에 추가 쿼리를 전송하지 않습니다

---
## 그럼 패치쪼인은 만능이네요? 
![](https://velog.velcdn.com/images/dreamdp01/post/02d24985-b62d-471f-a490-e53205f041b2/image.png)

패치 조인은 N+1 문제를 해결하지만, 1:N 관계를 패치 조인하면서 페이징 API(Pageable)를 사용할 경우 심각한 성능 문제가 발생합니다.

1:N 패치 조인 시 페이징 문제점

```java
// 1:N 관계에서 Fetch Join과 Pageable을 함께 사용하면 경고가 발생함
@Query("select m from Member m join fetch m.todoList")
Page<Member> findAllPage(Pageable pageable);
```
위 코드를 실행하면 하이버네이트는 다음과 같은 경고 로그를 출력하고, 메모리에서 페이징 처리를 수행합니다.
```
WARN: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!
```
#### 동작 방식

1. 하이버네이트는 데이터베이스에 `LIMIT`이나 `OFFSET` 쿼리를 전송하지 않고, 조건에 맞는 모든 데이터를 조회하는 쿼리를 실행합니다

2. 조회된 전체 데이터를 애플리케이션 메모리(Heap)로 로딩합니다

3. 메모리에 적재된 데이터를 기반으로 페이징 처리를 수행하여 결과를 반환합니다

결과: 데이터베이스의 데이터 양이 많을 경우, 애플리케이션 서버의 메모리 사용량이 급증하여 **OutOfMemoryError(OOM)**가 발생할 수 있습니다. 따라서 1:N 관계의 패치 조인에서는 페이징을 사용하면 큰일납니다

---

### 해결방법이 패치조인 밖에 없나요? 
패치조인 말고 Batch 사이즈를 조절하여 문제를 해결할 수 있습니다. 이 방법은 N개의 쿼리를 IN 절을 사용한 1번의 쿼리로 묶어서 조회하는 방식입니다.

application.yml 파일에 다음과 같이 설정을 추가합니다.

```YAML

spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100 # 한 번에 IN 절로 가져올 상위 엔티티의 개수
```

#### BatchSize의 동작 원리
이 옵션을 적용하면 지연 로딩된 데이터를 조회할 때, 하나씩 조회하는 것이 아니라 설정된 개수만큼 PK를 모아서 `IN` 쿼리로 한 번에 조회합니다

`findAll`을 통해 Member 데이터를 먼저 조회합니다 (여기서는 페이징 쿼리가 정상적으로 DB에 전송됩니다)

이후 루프를 돌며 `getTodoList()`를 호출하는 시점에, 하이버네이트는 이미 조회된 Member들의 ID를 모아 다음과 같은 쿼리를 날립니다.


```sql
SELECT * FROM TODO WHERE member_id IN (1, 2, 3, ... 100)
```
이 방식은 쿼리가 2번(Member 조회 1번 + Todo 조회 1번) 나가지만, 페이징 처리가 가능하다는 큰 장점이 있습니다

---
## 정리
N+1 문제를 해결하기 위해 `EntityGraph`나 `BatchSize` 등 여러 방법이 있다는 것을 공부했습니다.

아직 저는 학생이라 대규모 트래픽이 발생하는 실무 환경을 직접 경험해보진 못했지만 하지만 여러 글을 찾아보고 공부해보니, 결국 **가장 직관적이고 많이 사용되는 해결책은 Fetch Join**이라는 생각이 들었습니다. 개발자가 의도한 대로 쿼리를 한 번에 묶어서 가져온다는 점이 가장 명확했기 때문입니다.

이번에 N+1 문제를 정리하면서 느낀 점은, **JPA가 아무리 편해도 결국 실제 나가는 쿼리를 모르면 안 된다**입니다. 자동화된 도구 뒤에서 어떤 쿼리가 실행되는지 항상 로그를 확인하고 검증하는 습관을 들여야좋을것 같습니다.

