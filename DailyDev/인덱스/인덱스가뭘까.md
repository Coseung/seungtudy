# 인덱스가 뭘까 
인덱스 = 색인 
![](https://velog.velcdn.com/images/dreamdp01/post/a43d2e39-aea6-42fb-b050-756917932550/image.png)
![](https://velog.velcdn.com/images/dreamdp01/post/30c8fea8-1a0d-42cc-b14d-594c50c64c79/image.png)
출처 : 나무위키

색인은 어떤 쿠러미들에 들어있는 내용에 대한 지름길 정보를 가진 일종의 표 이다. 
보통 사전 맨 뒤나 앞에 단어를 찾아보는 색인이 있다. 
>
예
>- 3학년 2반 13번
>- 교육원 Q 강의장

데이터 베이스에도 똑같이 원하는 데이터를 빨리 찾으려고 만든 인덱스가 있다

---
## 인덱스가 없으면?
예를 들어 이름이 최개발인 회원을 조회한다고 치면 

![](https://velog.velcdn.com/images/dreamdp01/post/5f817c0c-0991-4651-a847-4e5f3538117a/image.png)


- 먼저 데이터 베이스의 맨 위부터 회원을 확인 
- 순차적으로 내려가서 최개발 회원 조회


이런 순서로 진행 된다 이게 `FULL TABLE SCAN`이다
이렇게 진행된다면 데이터가 많아지면 매우 느려지는 단점이있다

### 근데 Full Table Scan이 무조건 나쁜건 아님
![](https://velog.velcdn.com/images/dreamdp01/post/2d21db13-7d9a-4c16-8481-d1050d074a64/image.png)

- 테이블이 엄청 작으면 그냥 훑는게 더 빠를 수도 있다.
- 조선에 맞는 데이터가 테이블 대부분이면, 인덱스를 생성해도 필요없는데 추가공간 생성
- 적용 가능한 인덱스가 없거나, 인덱스로 처리 범위가 너무 넓으면 그냥 스캔이 선택되기도 함

---
## 그럼 인덱스가 있으면 왜 빨라짐?
DB 인덱스의 대표적인 구조가 B-Tree계열이다 
B-Tree 는 이진 탐색 트리의 단점을 보완한 구조라고 많이 설명한다.

이진 탐색 트리는 이 블로그를 찾아보면 좋을것같다. 간단하게 잘 나와있다.
[이진탐색 트리, B-tree 정리 블로그](https://darrengwon.tistory.com/874)

### B-Tree 특징
![](https://velog.velcdn.com/images/dreamdp01/post/ae5bd392-5fe6-4df1-9aa8-4aa1ba043667/image.png)

- 균형트리라서 한쪽으로 쏠려 느려지는 이진탐색트리의 단점을 보완
![](https://velog.velcdn.com/images/dreamdp01/post/ceb975d0-1d7b-4c5c-a709-58c4e85b423d/image.png)

- 자식 노드를 2개 만 가질수 있는 이진탐색과 다르게 2개이상 가질 수 있음
- 결과적으로 탐색할 때 범위를 확 줄이면서 내려가서 찾을 수 있음

그래서 WHERE name = '최개발' 처럼 조건이 인덱스를 타면
테이블 전체를 훑는 게 아니라 인덱스 트리를 타고 내려가면서 찾게 돼서 빠르다

---
## 인덱스 특징

- 인덱스는 데이터베이스 테이블에 대한 **검색 성능을 향상**시키는 자료구조
- 주로 WHERE, JOIN, ORDER BY 같은데서 활용
- 인덱스도 DB 객체라서 따로 저장공간이 필요( 약 10% )

### 인덱스 그럼 막 여러개 만들면 좋겠네?
>아님..


인덱스는 정렬상태를 유지해야해서 삽입, 수정, 삭제 할때마다 인덱스도 같이 수정됨. 그래서 인덱스를 많이 만들면 조회는 빨라질수 있는데 쓰기 작업이 많으면 오히려 부담이 커진다.

---
## 클러스터링 vs 논 - 클러스터링 
클러스터(Clustered)란?
무리, 군집 
무리를 이룬다는 의미이다.

클러스터링은 말 그대로 데이터가 인덱스 기준으로 한 무리처럼 묶여 정렬되는 방식이라고 보면 된다.

- **클러스터링 인덱스**: 실제 데이터(테이블)가 인덱스 키 순서대로 정렬되어 저장됨

- **논-클러스터링 인덱스**: 실제 데이터는 그대로 두고, 인덱스는 **별도로 만들어서 데이터 위치(주소/참조값)**만 저장함

---
## 클러스터링 인덱스(Clustered Index)
클러스터링 인덱스는 인덱스 키 순서대로 실제 데이터가 정렬된다.
![](https://velog.velcdn.com/images/dreamdp01/post/3673a448-29c3-4345-968e-bcb4add652e9/image.png)

- 실제 데이터 자체가 리프페이지에 정렬됨
- 테이블당 1개만 가능 
- 보통 Primary Key만들면 자동으로 생성됨, 또는 UNIQUE+NOT NULL 조합으로도 생성 가능

구조를 보면
- 루트 페이지(Root)
- 브랜치 페이지(중간 노드) -> 간단하면 없어도됨 
- 리프 페이지(Leaf) = 여기에 실제 데이터가 있음

클러스터링 인덱스는 루트페이지에 실제 데이터 페이지 ID를 넣고  리프페이지 에 실제 데이터가 있어 검색할때 

```
[Root Page]
   ↓
[Branch Page(들)]
   ↓
[Leaf Page = 실제 데이터 페이지]
   ↓
[행(Row) 읽기]
```
이 순으로 동작한다.

예를 들어서 유바다 라는 사람을 검색한다면 
![](https://velog.velcdn.com/images/dreamdp01/post/aa2779f2-562a-4ff0-b0e8-e2a0cdc8e66c/image.png)
이런식으로 ID로 빠르게 원하는 값을 찾을 수 있다.

---
## 논 - 클러스터링
마지막으로 논 클러스터링은 클러스터링이랑 반대로 
- 실제 데이터는 정렬되지 않는다.
- 대신 별도의 인덱스 페이지 구조을 만든다 
![](https://velog.velcdn.com/images/dreamdp01/post/952d4d15-5f51-4f2f-bba6-49cb651254db/image.png)


논클러스터링 인덱스의 리프페이지에는 보통 실제 값이 아니라 
데이터가 있는 위치/주소값 또는 PK값 같은 정보가 들어가있다.

#### 특징 
- 테이블당 여러개 생성가능 
- 추가 저장공간 필요
- INSERT/UPDATE/DELETE 시에 인덱스도 같이 관리해야해서 쓰기비용이 증가한다.
-보통 UNIQUE 제약조건 걸면 자동으로 생성됨
- SQL로 직접 CREATE INDEX 해서 만들 수 있음 

사진에서 indexTest3 를 찾는다고 하면

![](https://velog.velcdn.com/images/dreamdp01/post/1d1c4e0b-1bf5-4c23-bef5-668b21ba76c3/image.png)
101페이지의 자식노드의 3번 컬럼 `102+#3` 으로 들어가 실제 데이터에서 값을 가져온다 

---
## 정리

인덱스는 테이블에서 데이터를 찾을 때 사용하는 정렬된 자료구조(B-Tree) 이다.
WHERE, JOIN, ORDER BY, GROUP BY 같은 조건에서 검색 성능을 높일 수 있다.

하지만 인덱스는 별도의 구조로 저장되기 때문에 저장공간이 추가로 필요하고,
`INSERT` / `UPDATE` / `DELETE`가 발생하면 인덱스도 함께 변경되어야 해서 쓰기 비용이 증가할 수 있다.
특히 논-클러스터링 인덱스는 데이터와 별도로 관리되므로, 데이터 변경 시 인덱스에도 (키, 주소/참조값)을 삽입/삭제/갱신해야 한다.

따라서 인덱스는 **무조건 많이 만드는 것이 아니**라,** 자주 실행되는 쿼리 패턴 기준으로 필요한 컬럼**에만 생성하는 것이 좋다.

- `WHERE` 조건에 자주 쓰는 컬럼
- JOIN`에 자주 쓰는 컬럼
- `ORDER BY` / `GROUP BY`에서 자주 쓰는 컬럼

반대로, 변경(INSERT/UPDATE/DELETE)이 매우 많은 테이블에 인덱스를 과도하게 만들면 성능이 나빠질 수 있다.
